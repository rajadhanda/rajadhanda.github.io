<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Raja Dhanda</title>
  
  <!-- Favicons -->
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <!-- Pastel elements updated -->

  <!-- Theme Script (inline to prevent FOUC) -->
  <script>
    (function(){
      const savedTheme = localStorage.getItem('theme') || 'light';
      if (savedTheme === 'midnight') {
        document.documentElement.setAttribute('data-theme', 'midnight');
      }
    })();
  </script>

  <!-- Type -->
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=Inter:wght@300;400;500&display=swap" rel="stylesheet">

  <!-- Icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" referrerpolicy="no-referrer"/>

  <style>
    :root{
      --bg:#FFF8F0; --fg:#1a1a1a; --fg-light:#404040; --muted:#686868;
      --accent:#2a2a2a; --accent-soft:#f8f8f8;
      --border:#e8e8e8; --border-hover:#d4d4d4;
      --maxw:880px; --menu-w:420px;
      --ease:cubic-bezier(.16,1,.3,1);
      --ease-back:cubic-bezier(.34,1.56,.64,1);
      --shadow-soft:0 2px 20px rgba(0,0,0,.06);
      --shadow-medium:0 8px 30px rgba(0,0,0,.12);
      
      /* Pastel Color Palette */
      --pastel-mint:#E8F8F5; --pastel-mint-dark:#B8E6D9;
      --pastel-lavender:#F0E8FF; --pastel-lavender-dark:#D4C2F0;
      --pastel-peach:#FFE8E0; --pastel-peach-dark:#FFD4C2;
      --pastel-sky:#E8F4FD; --pastel-sky-dark:#B8D9F0;
      --pastel-rose:#FFE8F0; --pastel-rose-dark:#FFD4E6;
      --pastel-cream:#FFF8E8; --pastel-cream-dark:#FFE6B8;
      
      /* Blog-specific colors */
      --blog-bg:var(--bg); --blog-card-bg:rgba(255,255,255,0.8);
      --blog-accent:#2CA58D; --blog-text:#0A2540;
      --blog-meta:var(--muted); --blog-border:rgba(44,165,141,0.3);
    }
    
    /* Midnight Mode */
    [data-theme="midnight"]{
      --bg:#0a0e27; --fg:#e8ecf4; --fg-light:#b8c5d9; --muted:#7a8ca8;
      --accent:#a8b8d9; --accent-soft:#141b33;
      --border:#1a2340; --border-hover:#243155;
      --shadow-soft:0 2px 20px rgba(0,0,0,.3);
      --shadow-medium:0 8px 30px rgba(0,0,0,.5);
      
      /* Midnight Pastel Palette (darker, muted versions) */
      --pastel-mint:#1a2833; --pastel-mint-dark:#2a3d4d;
      --pastel-lavender:#1f1f33; --pastel-lavender-dark:#2d2d4a;
      --pastel-peach:#332020; --pastel-peach-dark:#4a2d2d;
      --pastel-sky:#1a2433; --pastel-sky-dark:#2a3547;
      --pastel-rose:#331f28; --pastel-rose-dark:#4a2d3a;
      --pastel-cream:#332d1f; --pastel-cream-dark:#4a4230;
      
      /* Midnight Blog colors */
      --blog-bg:#0f1524; --blog-card-bg:rgba(26,30,47,0.6);
      --blog-accent:#00A896; --blog-text:#E8ECF4;
      --blog-meta:var(--muted); --blog-border:rgba(0,168,150,0.2);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:'Crimson Text',serif; background:var(--bg); color:var(--fg);
      display:grid; grid-template-rows:1fr auto; align-items:center; justify-items:center;
      overflow-x:hidden; line-height:1.6;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    @media (max-width:768px){
      body{min-height:100vh; min-height:100dvh}
    }

    .sr-only{
      position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0);
      border:0;
    }

    /* Theme Toggle Button */
    .theme-toggle{
      position:fixed; top:28px; right:28px; width:52px; height:52px; border-radius:50%;
      border:1px solid var(--border); display:grid; place-items:center;
      background:rgba(254,254,254,.92); backdrop-filter:blur(12px);
      cursor:pointer; z-index:1001; box-shadow:var(--shadow-soft);
      opacity:0; transform:translateY(16px);
      transition:opacity .6s var(--ease), transform .6s var(--ease), all .3s var(--ease);
      -webkit-tap-highlight-color:rgba(0,0,0,0.05);
      touch-action:manipulation;
    }
    .theme-toggle.reveal{
      opacity:1; transform:translateY(0);
    }
    [data-theme="midnight"] .theme-toggle{
      background:rgba(26,30,47,.92);
    }
    .theme-toggle:hover{
      transform:scale(1.05) translateY(-1px); border-color:var(--border-hover); box-shadow:var(--shadow-medium);
    }
    .theme-toggle.reveal:hover{
      transform:scale(1.05) translateY(-1px) !important;
    }
    .theme-toggle i{
      font-size:18px; color:var(--fg); transition:transform .4s var(--ease-back), opacity .3s var(--ease);
    }
    .theme-toggle:hover i{
      transform:rotate(15deg);
    }
    .theme-toggle .fa-moon{opacity:1}
    .theme-toggle .fa-sun{opacity:0; position:absolute}
    [data-theme="midnight"] .theme-toggle .fa-moon{opacity:0}
    [data-theme="midnight"] .theme-toggle .fa-sun{opacity:1}
    @media (prefers-reduced-motion: reduce){
      .theme-toggle{transform:none; transition:opacity .3s var(--ease), all .3s var(--ease)}
    }
    
    /* Smooth theme transition */
    body{
      transition:background-color 0.5s var(--ease), color 0.5s var(--ease);
    }

    /* Top-left menu */
    .menu-toggle{
      position:fixed; top:28px; left:28px; width:52px; height:52px; border-radius:50%;
      border:1px solid var(--border); display:grid; place-items:center;
      background:rgba(254,254,254,.92); backdrop-filter:blur(12px);
      cursor:pointer; transition:all .3s var(--ease); z-index:1001; box-shadow:var(--shadow-soft);
      -webkit-tap-highlight-color:rgba(0,0,0,0.05);
      touch-action:manipulation;
    }
    [data-theme="midnight"] .menu-toggle{
      background:rgba(26,30,47,.92);
    }
    .menu-toggle:hover{transform:scale(1.05) translateY(-1px); border-color:var(--border-hover); box-shadow:var(--shadow-medium)}
    .menu-toggle i{font-size:18px; color:var(--fg); transition:transform .2s var(--ease)}
    .menu-toggle:hover i{transform:rotate(12deg)}

    /* Slide-out panel */
    .panel{
      position:fixed; inset:0 auto 0 0; width:min(100%,var(--menu-w)); max-width:92vw;
      background:var(--accent-soft); border-right:1px solid var(--border);
      transform:translateX(-100%); transition:transform .6s var(--ease); z-index:1000;
      display:flex; flex-direction:column; padding:32px 32px 36px; overflow-y:auto; backdrop-filter:blur(20px)
    }
    .panel.open{transform:translateX(0)}
    .panel header{
      font-family:'Inter',sans-serif; font-size:.85rem; color:var(--muted);
      letter-spacing:.08em; text-transform:uppercase; margin-bottom:24px; font-weight:500
    }
    nav ul{list-style:none; padding:0; margin:0 0 32px}
    nav li{margin:0; border-bottom:1px solid rgba(0,0,0,.04)}
    nav li:last-child{border-bottom:none}
    nav a{
      text-decoration:none; color:var(--fg); font-size:1.4rem; font-weight:400;
      transition:all .3s var(--ease); display:block; padding:14px 0; position:relative; overflow:hidden
    }
    nav a::before{
      content:''; position:absolute; bottom:0; left:-100%; width:100%; height:1px; background:var(--fg);
      transition:left .4s var(--ease)
    }
    nav a:hover::before{left:0}
    nav a:hover{color:var(--accent); transform:translateX(4px)}
    .about{margin-top:24px; border-top:1px solid var(--border); padding-top:24px; max-width:42ch; line-height:1.55; color:var(--fg-light); font-size:1.05rem}
    .about h3{margin:0 0 12px 0; font-size:1.2rem; color:var(--accent); font-family:'Inter',sans-serif; font-weight:500}

    /* Main */
    main{width:100%; max-width:var(--maxw); text-align:center; padding:40px 20px; align-self:center; justify-self:center; position:relative; z-index:2}
    @media (max-width:768px){
      main{padding:32px 20px 20px}
    }
    @media (max-width:560px){
      main{padding:28px 16px 16px}
    }
    @media (max-width:380px){
      main{padding:24px 14px 14px}
    }
    #centerpiece{display:inline-block}
    /* Profile Photo */
    .profile-photo-container{
      margin:0 0 24px 0; display:flex; justify-content:center; align-items:center;
      opacity:0; transform:translateY(20px) scale(0.9);
      transition:opacity 1.2s var(--ease), transform 1.2s var(--ease);
      position:relative;
    }
    .profile-photo-container.show{
      opacity:1; transform:translateY(0) scale(1);
    }
    
    .profile-photo{
      width:140px; height:161px;
      border-radius:16px; object-fit:contain; object-position:center;
      background: var(--bg);
      max-width: 100%; max-height: 100%;
    }

    .name{
      font-family:'Playfair Display',serif;
      font-size:clamp(2rem,5vw,4rem); line-height:1.08; margin:0 0 16px 0; min-height:1.2em;
      letter-spacing:-.02em; font-weight:400; position:relative;
      padding:0 20px;
    }
    @media (max-width:560px){
      .name{padding:0 16px}
    }
    @media (max-width:380px){
      .name{padding:0 12px}
    }
    .typing-cursor{display:inline-block; width:3px; height:1em; background:var(--fg); margin-left:4px; transform:translateY(.05em); animation:cursor-blink 1.4s ease-in-out infinite; border-radius:1px}
    @keyframes cursor-blink{0%,45%{opacity:1}50%,95%{opacity:.1}100%{opacity:1}}

    .subtitle{
      font-size:clamp(1.2rem,2.4vw,1.8rem); color:var(--muted); font-weight:400; font-style:italic;
      margin:20px 0 0 0; opacity:0; transform:translateY(12px);
      transition:opacity 1s var(--ease), transform 1s var(--ease); letter-spacing:.01em;
      padding:0 20px;
    }
    @media (max-width:560px){
      .subtitle{padding:0 16px}
    }
    @media (max-width:380px){
      .subtitle{padding:0 12px}
    }
    .subtitle.show{opacity:1; transform:translateY(0)}

    /* Socials */
    .social-links{margin-top:28px; display:flex; gap:32px; justify-content:center; align-items:center}
    .social-link{opacity:0; transform:translateY(6px) scale(.94)}
    .social-links.icons-in .social-link{animation:icon-pop .46s var(--ease-back) forwards}
    .social-links.icons-in .social-link:nth-child(2){animation-delay:.08s}
    @keyframes icon-pop{0%{opacity:0; transform:translateY(6px) scale(.94)}60%{opacity:1; transform:translateY(0) scale(1.045)}100%{opacity:1; transform:translateY(0) scale(1)}}
    .social-link{
      display:inline-flex; align-items:center; justify-content:center; text-decoration:none; color:var(--fg);
      font-size:18px; width:52px; height:52px; border:1px solid var(--border); border-radius:50%;
      background:rgba(254,254,254,.92); backdrop-filter:blur(12px);
      transition: transform .3s var(--ease), border-color .5s var(--ease), box-shadow .3s var(--ease), background .5s var(--ease), color .5s var(--ease);
      position:relative; overflow:hidden; box-shadow:var(--shadow-soft);
      -webkit-tap-highlight-color:rgba(0,0,0,0.05);
      touch-action:manipulation;
    }
    [data-theme="midnight"] .social-link{
      background:rgba(26,30,47,.92);
    }
    .social-link i{
      transition:transform .4s var(--ease-back), color .5s var(--ease);
    }
    .social-link:hover i{
      transform:rotate(15deg);
    }
    .social-link::before{content:''; position:absolute; inset:0; border-radius:50%; transform:scale(0); transition:transform .5s var(--ease); z-index:-1}
    .social-link:hover::before{transform:scale(1)}
    .social-link:hover{color:white; transform:scale(1.05) translateY(-1px); box-shadow:var(--shadow-medium); border-color:transparent}
    
    /* Platform-specific brand colors */
    .social-link[aria-label="LinkedIn"]:hover{
      border-color:#0077b5; background:#0077b5; color:white;
    }
    .social-link[aria-label="LinkedIn"]:hover::before{
      background:#0077b5;
    }
    .social-link[aria-label="Email"]:hover{
      border-color:#007AFF; background:#007AFF; color:white;
    }
    .social-link[aria-label="Email"]:hover::before{
      background:#007AFF;
    }
    
    /* Subtle ripple effect */
    .social-link::after{
      content:''; position:absolute; top:50%; left:50%; width:0; height:0;
      border-radius:50%; background:rgba(255,255,255,.3); transform:translate(-50%, -50%) scale(0);
      pointer-events:none; z-index:1;
    }
    .social-link:active::after{
      animation:ripple 0.5s var(--ease-back) forwards;
    }
    @keyframes ripple{
      0%{width:0; height:0; opacity:1}
      100%{width:120px; height:120px; opacity:0}
    }
    @media (prefers-reduced-motion: reduce){
      .social-link::after{display:none}
    }

    /* Global button press animations */
    button, .nav-back, .lightbox-nav, .scroll-to-top{
      transition:transform 0.15s var(--ease), box-shadow 0.15s var(--ease);
    }
    button:active, .nav-back:active, .lightbox-nav:active, .scroll-to-top:active{
      transform:scale(0.97) translateY(1px);
    }
    @media (prefers-reduced-motion: reduce){
      button:active, .nav-back:active, .lightbox-nav:active, .scroll-to-top:active{
        transform:none;
      }
    }

    /* Subtle ornaments */
    .floating-element{position:absolute; pointer-events:none; opacity:.15; color:var(--muted); font-size:12px; animation:float 8s ease-in-out infinite; z-index:-1}
    .floating-element.pastel-1{color:var(--pastel-lavender-dark); opacity:.4; font-size:16px; animation:float 10s ease-in-out infinite}
    .floating-element.pastel-2{color:var(--pastel-mint-dark); opacity:.35; font-size:12px; animation:float 12s ease-in-out infinite}
    @keyframes float{0%,100%{transform:translateY(0) rotate(0)}33%{transform:translateY(-8px) rotate(2deg)}66%{transform:translateY(4px) rotate(-1deg)}}
    .floating-element:nth-child(1){top:15%; right:10%; animation-delay:-2s}
    .floating-element:nth-child(2){bottom:20%; left:8%; animation-delay:-5s; animation-duration:12s}
    .floating-element.pastel-1{top:25%; left:12%; animation-delay:-8s; animation-duration:15s}
    .floating-element.pastel-2{bottom:35%; right:15%; animation-delay:-12s; animation-duration:18s}

    /* Status chip */
    .status{
      position:fixed; bottom:28px; right:28px; font-family:'Inter',sans-serif; font-size:.8rem; color:var(--muted);
      display:flex; align-items:center; gap:8px; background:rgba(254,254,254,.9); backdrop-filter:blur(8px);
      padding:8px 16px; border-radius:20px; border:1px solid var(--border); opacity:0; animation:fadeInUp .8s ease-out 3s forwards; z-index:2
    }
    .status-dot{width:6px; height:6px; background:#22c55e; border-radius:50%; animation:pulse 2s ease-in-out infinite}
    @keyframes pulse{0%,100%{opacity:1; transform:scale(1)}50%{opacity:.6; transform:scale(1.1)}}
    @keyframes fadeInUp{from{opacity:0; transform:translateY(10px)}to{opacity:1; transform:translateY(0)}}

    /* Backdrop */
    .overlay{position:fixed; inset:0; background:rgba(0,0,0,0); backdrop-filter:blur(0); opacity:0; visibility:hidden; transition:all .4s var(--ease); z-index:999}
    .overlay.active{background:rgba(0,0,0,.1); backdrop-filter:blur(2px); opacity:1; visibility:visible}

    /* Bubble navigation (grid fallback for reduced motion) */
    .bubble-nav{
      margin-top:6vh; display:grid; grid-template-columns:repeat(2, minmax(160px,1fr));
      gap:clamp(16px,5vw,36px); align-items:center; justify-items:center;
    }
    @media (max-width:768px){
      .bubble-nav{gap:clamp(14px,4vw,28px); margin-top:5vh}
    }
    @media (max-width:560px){
      .bubble-nav{grid-template-columns:1fr 1fr; gap:16px; margin-top:4vh}
    }
    @media (max-width:380px){
      .bubble-nav{gap:14px; margin-top:3vh}
    }

    .bubble{
      position:relative; width:clamp(120px,18vw,165px); aspect-ratio:1/1; border-radius:50%;
      border:2px solid var(--border); display:grid; place-items:center; text-decoration:none; color:var(--fg);
      overflow:hidden; background:transparent;
      /* JS owns transform entirely for silky motion */
      transition: border-color .18s var(--ease), box-shadow .18s var(--ease);
      will-change: transform;
      backface-visibility:hidden; transform:translate3d(0,0,0);
      /* Better touch targets on mobile */
      -webkit-tap-highlight-color:rgba(0,0,0,0.05);
      touch-action:manipulation;
    }
    .bubble:hover{border-color:var(--muted); box-shadow:0 10px 24px rgba(0,0,0,.08)}
    .bubble:focus-visible{outline:none; box-shadow:0 0 0 3px rgba(0,0,0,.10), 0 10px 24px rgba(0,0,0,.08); border-color:var(--muted)}
    .bubble:active{transform:scale(0.98)}
    @media (max-width:560px){
      .bubble{-webkit-tap-highlight-color:rgba(0,0,0,0.08)}
    }
    
    /* Subtle pulse animation on hover */
    .bubble::before{
      content:''; position:absolute; inset:-4px; border-radius:50%; border:2px solid transparent;
      pointer-events:none; opacity:0; transition:opacity 0.3s var(--ease);
    }
    .bubble:hover::before{
      opacity:1; animation:gentle-pulse 2s ease-in-out infinite;
      border-color:rgba(255,255,255,0.4);
    }
    @keyframes gentle-pulse{
      0%, 100%{transform:scale(1); opacity:0.4}
      50%{transform:scale(1.05); opacity:0.6}
    }
    @media (prefers-reduced-motion: reduce){
      .bubble::before{display:none}
    }
    
    /* Page transition overlay */
    .page-transition{
      position:fixed; top:0; left:0; width:0; height:0; border-radius:50%;
      background:var(--bg); transform:translate(-50%, -50%);
      opacity:0; pointer-events:none; z-index:1500; transition:width 0.6s var(--ease-back), height 0.6s var(--ease-back), opacity 0.3s var(--ease);
      will-change: width, height;
    }
    .page-transition.active{
      opacity:1; pointer-events:all;
      width:200vw; height:200vh;
    }
    @media (prefers-reduced-motion: reduce){
      .page-transition{display:none}
    }

    .bubble-title{
      font-size:clamp(0.8rem,1.65vw,1.05rem); font-weight:500; line-height:1.2; text-align:center; pointer-events:none; color:#8c8c8c;
      position:relative; transition:transform .2s var(--ease);
    }
    .bubble:hover .bubble-title, .bubble[data-armed="1"] .bubble-title{
      transform:translateY(-8px);
    }
    .bubble-label{
      position:absolute; bottom:12px; left:50%; transform:translate(-50%,6px);
      font-style:italic; font-size:clamp(.62rem,1.2vw,.72rem); color:var(--muted);
      opacity:0; transition:opacity .2s var(--ease), transform .2s var(--ease);
      pointer-events:none; text-align:center; max-width:88%; line-height:1.25; white-space:normal; word-break:break-word
    }
    .bubble:hover .bubble-label,.bubble:focus-within .bubble-label,.bubble[data-armed="1"] .bubble-label{opacity:1; transform:translate(-50%,0)}
    /* Armed state on touch: subtle emphasis */
    .bubble[data-armed="1"]{ border-color:var(--muted); box-shadow:0 10px 24px rgba(0,0,0,.08) }
    .bubble[data-armed="1"] .bubble-label{ font-size:.62rem }

    /* Populated bubble styles - Photos (warm tones) */
    .photos-bubble{
      background:linear-gradient(135deg, var(--pastel-peach), var(--pastel-cream));
      border:2px solid var(--pastel-peach-dark);
      box-shadow:0 4px 20px rgba(255, 212, 194, 0.25), 0 8px 40px rgba(255, 230, 184, 0.15);
      animation:gentlePulse 4s ease-in-out infinite;
    }
    .photos-bubble:hover{
      background:linear-gradient(135deg, var(--pastel-peach-dark), var(--pastel-cream-dark));
      border-color:var(--muted);
      box-shadow:0 6px 30px rgba(255, 212, 194, 0.35), 0 12px 50px rgba(255, 230, 184, 0.25);
    }
    .photos-bubble .bubble-title{
      color:var(--accent);
      font-weight:600;
    }
    .photos-bubble .bubble-label{
      color:var(--fg-light);
    }

    /* Populated bubble styles - Blog (cool tones) */
    .blog-bubble{
      background:linear-gradient(135deg, var(--pastel-mint), var(--pastel-sky));
      border:2px solid var(--pastel-mint-dark);
      box-shadow:0 4px 20px rgba(184, 230, 217, 0.25), 0 8px 40px rgba(184, 217, 240, 0.15);
      animation:gentlePulse 4s ease-in-out infinite;
    }
    .blog-bubble:hover{
      background:linear-gradient(135deg, var(--pastel-mint-dark), var(--pastel-sky-dark));
      border-color:var(--muted);
      box-shadow:0 6px 30px rgba(184, 230, 217, 0.35), 0 12px 50px rgba(184, 217, 240, 0.25);
    }
    .blog-bubble .bubble-title{
      color:var(--accent);
      font-weight:600;
    }
    .blog-bubble .bubble-label{
      color:var(--fg-light);
    }

    /* Populated bubble styles - Projects (warm-cool blend) */
    .projects-bubble{
      background:linear-gradient(135deg, var(--pastel-lavender), var(--pastel-rose));
      border:2px solid var(--pastel-lavender-dark);
      box-shadow:0 4px 20px rgba(212, 194, 240, 0.25), 0 8px 40px rgba(255, 212, 230, 0.15);
      animation:gentlePulse 4s ease-in-out infinite;
    }
    .projects-bubble:hover{
      background:linear-gradient(135deg, var(--pastel-lavender-dark), var(--pastel-rose-dark));
      border-color:var(--muted);
      box-shadow:0 6px 30px rgba(212, 194, 240, 0.35), 0 12px 50px rgba(255, 212, 230, 0.25);
    }
    .projects-bubble .bubble-title{
      color:var(--accent);
      font-weight:600;
    }
    .projects-bubble .bubble-label{
      color:var(--fg-light);
    }

    /* Unpopulated bubble styles - muted and dimmed */
    .unpopulated-bubble{
      background:rgba(255, 255, 255, 0.3);
      border:2px solid var(--border);
      opacity:0.7;
      transition:opacity .3s var(--ease), border-color .3s var(--ease);
    }
    .unpopulated-bubble:hover{
      opacity:0.85;
      border-color:var(--muted);
    }
    .unpopulated-bubble:hover .bubble-label{
      opacity:0.8;
    }
    .unpopulated-bubble .bubble-title{
      color:var(--muted);
      font-weight:400;
    }
    .unpopulated-bubble .bubble-label{
      color:var(--muted);
      opacity:0;
    }

    /* Gentle pulse animation for populated bubbles */
    @keyframes gentlePulse{
      0%, 100%{box-shadow:0 4px 20px rgba(184, 230, 217, 0.15), 0 8px 40px rgba(184, 217, 240, 0.1)}
      50%{box-shadow:0 6px 25px rgba(184, 230, 217, 0.2), 0 12px 45px rgba(184, 217, 240, 0.15)}
    }

    /* Viewport-pinned physics layer */
    .bubble-nav.freeflow{
      position: fixed;
      inset: 0;              /* pin to viewport; avoids 100vw scrollbar shift */
      pointer-events: none;
      z-index: 3;            /* above main so bubbles remain hoverable near text */
      display: block;
      margin: 0;
      opacity: 0;            /* fade in when ready */
      transition: opacity .5s var(--ease);
    }
    .bubble-nav.freeflow .bubble{
      position: absolute;
      left: 0;               /* ensure transform origin is the viewport's top-left */
      top: 0;
      pointer-events: auto;
    }
    .bubble-nav.freeflow.ready{opacity:1}

    /* Reduced motion: keep centred positions without animation */
    @media (prefers-reduced-motion: reduce){
      .bubble-nav.freeflow{position:fixed; inset:0; width:100vw; height:100dvh; display:block; pointer-events:none; opacity:1 !important}
      .bubble-nav.freeflow .bubble{position:absolute}
      .social-link{opacity:1 !important; transform:none !important; animation:none !important}
    }

    /* Section base */
    .section{
      margin-top:48px; opacity:0; transform:translateY(16px);
      transition:opacity .6s var(--ease), transform .6s var(--ease);
    }
    .section.reveal{
      opacity:1; transform:translateY(0);
    }
    @media (prefers-reduced-motion: reduce){
      .section{transform:none; transition:opacity .3s var(--ease)}
    }

    /* Inline About Section */
    #about-inline.section{
      margin-top:32px; max-width:680px; margin-left:auto; margin-right:auto;
      text-align:center; color:var(--fg-light);
    }
    #about-inline .portrait{
      width:88px; height:88px; border-radius:50%; object-fit:cover; display:block; margin:0 auto 12px auto;
    }
    #about-inline .lede{
      font-size:clamp(0.95rem, 1.8vw, 1.05rem); line-height:1.5; margin:0; font-weight:400;
    }
    @media (max-width:768px){
      #about-inline .lede{
        font-size:0.9rem; line-height:1.4;
      }
    }
    @media (max-width:560px){
      #about-inline .lede{
        font-size:0.85rem; line-height:1.35;
      }
    }
    @media (max-width:380px){
      #about-inline .lede{
        font-size:0.8rem; line-height:1.3;
      }
    }


    /* Hobby Icons Section */
    #hobbies{
      margin-top:80px; max-width:500px; margin-left:auto; margin-right:auto;
      text-align:center;
      padding:0 20px;
      position:fixed; bottom:20px; left:50%;
      width:100%; max-width:500px;
      transform:translateX(-50%) translateY(20px);
      opacity:0;
      visibility:hidden;
      pointer-events:none;
      transition:opacity 0.5s var(--ease), transform 0.5s var(--ease), visibility 0.5s var(--ease);
      z-index:10;
    }
    #hobbies.reveal{
      transform:translateX(-50%) translateY(0);
      opacity:1;
      visibility:visible;
      pointer-events:auto;
    }
    .hobbies-label{
      font-family:'Inter',sans-serif; font-size:0.75rem; color:var(--muted);
      margin:0; margin-right:10px; font-weight:400; font-style:italic;
      white-space:nowrap;
    }
    .hobby-icons{
      display:flex; flex-wrap:wrap; gap:12px; justify-content:center;
      align-items:center;
    }
    .hobby-icon{
      display:inline-flex; align-items:center; justify-content:center;
      width:28px; height:28px;
      border:none; background:transparent;
      color:var(--muted); text-decoration:none;
      font-size:14px; transition:transform .3s var(--ease), color .4s var(--ease);
      position:relative;
      -webkit-tap-highlight-color:rgba(0,0,0,0.05);
      touch-action:manipulation;
    }
    .hobby-icon i{
      transition:transform .4s var(--ease-back), color .4s var(--ease);
    }
    .hobby-icon:hover i{
      transform:rotate(15deg);
    }
    .hobby-icon:hover{
      color:var(--fg);
      transform:scale(1.05) translateY(-1px);
    }
    .hobby-icon:focus-visible{
      outline:none; box-shadow:0 0 0 2px var(--accent);
    }
    @media (prefers-reduced-motion: reduce){
      .hobby-icon:hover{transform:none}
    }
    @media (max-width:768px){
      #hobbies{bottom:16px; padding:0 20px; max-width:450px}
      .hobby-icons{gap:12px}
      .hobby-icon{width:26px; height:26px; font-size:13px}
      .hobbies-label{font-size:0.72rem; margin-right:10px}
    }
    @media (max-width:560px){
      #hobbies{bottom:12px; padding:0 16px; max-width:380px}
      .hobby-icons{gap:10px}
      .hobby-icon{width:24px; height:24px; font-size:12px}
      .hobbies-label{font-size:0.7rem; margin-right:8px}
    }
    @media (max-width:380px){
      #hobbies{bottom:10px; padding:0 14px; max-width:340px}
      .hobby-icons{gap:8px}
      .hobby-icon{width:22px; height:22px; font-size:11px}
      .hobbies-label{font-size:0.68rem; margin-right:6px}
    }
    @media (prefers-reduced-motion: reduce){
      #hobbies{transform:translateX(-50%)}
    }

    /* Responsive tweaks */
    @media (max-width:768px){
      .menu-toggle{top:20px; left:20px; width:48px; height:48px}
      .theme-toggle{top:20px; right:20px; width:48px; height:48px}
      .panel{padding:24px}
      .about{max-width:100%}
      .social-links{margin-top:24px; gap:20px}
      .social-link{width:48px; height:48px; font-size:17px}
      .status{bottom:20px; right:20px; font-size:.75rem}
      .floating-element{display:none}
      .section{margin-top:32px}
      main{padding:32px 20px 20px}
      #about-inline{margin-top:28px; padding:0 12px}
      #about-inline .lede{font-size:1rem; line-height:1.7}
    }

    /* Mobile typography and bubble size tuning */
    @media (max-width:560px){
      .menu-toggle{top:16px; left:16px; width:44px; height:44px}
      .theme-toggle{top:16px; right:16px; width:44px; height:44px}
      main{padding:28px 16px 16px}
      .profile-photo{width:110px; height:127px; border-radius:14px; object-fit:contain; max-width: 100%; max-height: 100%;}
      .profile-photo-container{margin-bottom:20px}
      .name{font-size:clamp(1.4rem, 6vw, 2rem); margin-bottom:12px; line-height:1.1}
      .subtitle{font-size:clamp(1rem, 4vw, 1.2rem); margin-top:16px; letter-spacing:.02em}
      .social-links{margin-top:20px; gap:18px}
      .social-link{width:44px; height:44px; font-size:16px}
      .bubble{width:clamp(70px, 20vw, 95px)}
      .bubble-title{font-size:clamp(0.7rem, 1.8vw, 0.85rem); font-weight:500}
      .bubble:hover .bubble-title, .bubble[data-armed="1"] .bubble-title{
        transform:translateY(-6px);
      }
      .bubble-label{font-size:.55rem; bottom:10px; max-width:90%}
      .bubble[data-armed="1"] .bubble-label{font-size:.52rem}
      #about-inline{margin-top:24px; padding:0 8px}
      #about-inline .lede{font-size:0.95rem; line-height:1.65}
      .section{margin-top:28px}
    }
    @media (max-width:380px){
      .menu-toggle{top:14px; left:14px; width:42px; height:42px}
      .theme-toggle{top:14px; right:14px; width:42px; height:42px}
      main{padding:24px 14px 14px}
      .profile-photo{width:100px; height:115px; border-radius:12px; object-fit:contain; max-width: 100%; max-height: 100%;}
      .profile-photo-container{margin-bottom:18px}
      .name{font-size:clamp(1.3rem, 6.5vw, 1.8rem); margin-bottom:10px}
      .subtitle{font-size:clamp(0.95rem, 4.2vw, 1.1rem); margin-top:14px}
      .social-links{margin-top:18px; gap:16px}
      .social-link{width:42px; height:42px; font-size:15px}
      .bubble{width:clamp(65px, 22vw, 85px)}
      .bubble-title{font-size:clamp(0.65rem, 1.6vw, 0.78rem)}
      .bubble:hover .bubble-title, .bubble[data-armed="1"] .bubble-title{
        transform:translateY(-5px);
      }
      .bubble-label{font-size:.52rem; bottom:8px}
      .bubble[data-armed="1"] .bubble-label{font-size:.48rem}
      #about-inline{margin-top:20px; padding:0 6px}
      #about-inline .lede{font-size:0.9rem; line-height:1.6}
      .section{margin-top:24px}
    }
  </style>
</head>
<body>

  <!-- Theme Toggle Button -->
  <button class="theme-toggle" id="themeToggle" aria-label="Toggle midnight mode">
    <i class="fa-solid fa-moon" aria-hidden="true"></i>
    <i class="fa-solid fa-sun" aria-hidden="true"></i>
  </button>

  <!-- Ornaments -->
  <div class="floating-element">✦</div>
  <div class="floating-element">◇</div>
  <div class="floating-element pastel-1">◈</div>
  <div class="floating-element pastel-2">◊</div>

  <!-- Menu removed -->

  <!-- Panel -->
  <aside class="panel" id="panel" aria-hidden="true" style="display:none">
    <header>Navigation</header>
    <nav aria-label="Primary">
      <ul>
        <li><a href="/blog/">Blog</a></li>
        <li><a href="/projects/">Projects</a></li>
        <li><a href="/photographs/">Photographs</a></li>
      </ul>
    </nav>
  </aside>


  <!-- Main -->
  <main>
    <div id="centerpiece">
      <h1 class="name" id="name" data-text="Raja Dhanda"></h1>
      <div class="profile-photo-container">
        <img src="assets/images/IMG_6767.jpeg" alt="Raja Dhanda" class="profile-photo" id="profilePhoto" loading="lazy" width="140" height="161">
      </div>
      <div class="subtitle" id="subtitle">experimenting with intention</div>

      <div class="social-links" aria-label="Connect with me">
        <a class="social-link" href="https://www.linkedin.com/in/ramendra-raja-dhanda/" target="_blank" rel="noopener" aria-label="LinkedIn">
          <i class="fa-brands fa-linkedin" aria-hidden="true"></i>
        </a>
        <a class="social-link" href="mailto:hello@rajadhanda.me" target="_blank" rel="noopener" aria-label="Email">
          <i class="fa-solid fa-envelope" aria-hidden="true"></i>
        </a>
      </div>

      <!-- Inline About Section -->
      <section id="about-inline" class="section">
        <p class="lede">Emerging technology and innovation consultant, working in fintech. Learning, building and failing - please reach out with any opportunities!</p>
      </section>

      <!-- Hobby Icons Section -->
      <section id="hobbies" class="hobbies section">
        <div class="hobby-icons">
          <p class="hobbies-label">always happy to chat about</p>
          <a href="mailto:hello@rajadhanda.me?subject=Coffee" class="hobby-icon" aria-label="Coffee" data-tooltip="Coffee">
            <i class="fa-solid fa-mug-hot" aria-hidden="true"></i>
          </a>
          <a href="mailto:hello@rajadhanda.me?subject=Quantum%20Computing" class="hobby-icon" aria-label="Quantum Computing" data-tooltip="Quantum Computing">
            <i class="fa-solid fa-microchip" aria-hidden="true"></i>
          </a>
          <a href="mailto:hello@rajadhanda.me?subject=Football" class="hobby-icon" aria-label="Football" data-tooltip="Football">
            <i class="fa-solid fa-futbol" aria-hidden="true"></i>
          </a>
          <a href="mailto:hello@rajadhanda.me?subject=F1" class="hobby-icon" aria-label="F1" data-tooltip="F1">
            <i class="fa-solid fa-flag-checkered" aria-hidden="true"></i>
          </a>
        </div>
      </section>
    </div>
  </main>

  <!-- Page Transition Overlay -->
  <div class="page-transition" id="pageTransition"></div>

  <!-- Bubble navigation (freeflow enables physics) -->
  <nav id="bubbleNav" class="bubble-nav freeflow" aria-label="Primary">
    <a class="bubble photos-bubble" href="/photographs/" data-key="photos" aria-label="Photographs">
      <span class="bubble-title">Photographs</span>
      <em class="bubble-label">frames from my camera roll</em>
    </a>
    <a class="bubble blog-bubble" href="/blog/" data-key="blog" aria-label="Blog">
      <span class="bubble-title">Blog</span>
      <em class="bubble-label">notes and thought experiments</em>
    </a>
    <a class="bubble projects-bubble" href="/projects/" data-key="projects" aria-label="Projects">
      <span class="bubble-title">Projects</span>
      <em class="bubble-label">things I've tried</em>
    </a>
  </nav>

  <script>
    // ===== CRITICAL: Reset page state on load (especially for back navigation) =====
    (function(){
      function resetPageState() {
        // Immediately reset page transition overlay to ensure content is visible
        const pageTransition = document.getElementById('pageTransition');
        if (pageTransition) {
          pageTransition.classList.remove('active');
          // Force reset styles in case they're stuck
          pageTransition.style.width = '0';
          pageTransition.style.height = '0';
          pageTransition.style.opacity = '0';
          pageTransition.style.pointerEvents = 'none';
        }
        
        // Ensure body is visible and not blocked
        document.body.style.overflow = '';
        document.body.style.visibility = 'visible';
        
        // Reset ALL visibility states for animations to replay
        // Reset profile photo
        const profilePhotoContainer = document.querySelector('.profile-photo-container');
        if (profilePhotoContainer) {
          profilePhotoContainer.classList.remove('show');
        }
        
        // Reset subtitle
        const subtitleEl = document.getElementById('subtitle');
        if (subtitleEl) {
          subtitleEl.classList.remove('show');
        }
        
        // Reset social links
        const socialLinksEl = document.querySelector('.social-links');
        if (socialLinksEl) {
          socialLinksEl.classList.remove('icons-in');
          // Reset individual social link animations
          socialLinksEl.querySelectorAll('.social-link').forEach(link => {
            link.style.opacity = '0';
            link.style.transform = 'translateY(6px) scale(0.94)';
          });
        }
        
        // Reset all sections (about, hobbies, etc.)
        document.querySelectorAll('.section').forEach(section => {
          section.classList.remove('reveal');
        });
        
        // Reset hobbies section
        const hobbies = document.getElementById('hobbies');
        if (hobbies) {
          hobbies.classList.remove('reveal');
        }
        
        // Reset theme toggle
        const themeToggle = document.getElementById('themeToggle');
        if (themeToggle) {
          themeToggle.classList.remove('reveal');
        }
        
        // Reset bubbles navigation
        const bubbleNav = document.getElementById('bubbleNav');
        if (bubbleNav) {
          bubbleNav.classList.remove('ready');
        }
      }
      
      // Reset immediately
      resetPageState();
      
      // Reset on pageshow event (handles back/forward navigation from cache)
      window.addEventListener('pageshow', function(event) {
        // event.persisted is true when page is loaded from cache (back navigation)
        if (event.persisted) {
          resetPageState();
          // Force a reflow to ensure styles are applied
          void document.body.offsetHeight;
        }
      });
      
      // Also reset on DOMContentLoaded as a safety measure
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', resetPageState);
      }
    })();

    // ===== Theme Toggle (load first to prevent flash) =====
    (function(){
      const themeToggle = document.getElementById('themeToggle');
      const html = document.documentElement;
      
      // Load saved theme or default to light
      const savedTheme = localStorage.getItem('theme') || 'light';
      if (savedTheme === 'midnight') {
        html.setAttribute('data-theme', 'midnight');
      }
      
      // Theme toggle handler
      if (themeToggle) {
        themeToggle.addEventListener('click', ()=>{
          const currentTheme = html.getAttribute('data-theme');
          if (currentTheme === 'midnight') {
            html.removeAttribute('data-theme');
            localStorage.setItem('theme', 'light');
          } else {
            html.setAttribute('data-theme', 'midnight');
            localStorage.setItem('theme', 'midnight');
          }
        });
      }
    })();

    // ===== Theme Toggle: reveal on scroll or after time (same logic as hobbies) =====
    (function(){
      const themeToggle = document.getElementById('themeToggle');
      if (!themeToggle) return;

      const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      let revealed = false;
      let scrollRevealed = false;
      let timeRevealed = false;
      let timeRevealTimeout = null;
      let fallbackTimeout = null;
      
      function resetThemeToggleState() {
        revealed = false;
        scrollRevealed = false;
        timeRevealed = false;
        if (timeRevealTimeout) {
          clearTimeout(timeRevealTimeout);
          timeRevealTimeout = null;
        }
        if (fallbackTimeout) {
          clearTimeout(fallbackTimeout);
          fallbackTimeout = null;
        }
        themeToggle.classList.remove('reveal');
      }
      
      function revealThemeToggle() {
        if (revealed) return;
        revealed = true;
        themeToggle.classList.add('reveal');
      }
      
      function setupThemeToggleReveal() {
        resetThemeToggleState();
        
        // Scroll-based reveal
        function checkScroll() {
          if (scrollRevealed) return;
          const scrollY = window.pageYOffset || document.documentElement.scrollTop;
          if (scrollY > 200) {
            scrollRevealed = true;
            revealThemeToggle();
          }
        }
        
        // Time-based reveal (after user has been on page for a while)
        function handleIconsReady() {
          timeRevealTimeout = setTimeout(() => {
            if (!timeRevealed && !revealed) {
              timeRevealed = true;
              // Only reveal via time if user hasn't scrolled yet
              if (!scrollRevealed) {
                revealThemeToggle();
              }
            }
          }, 8000); // 8 seconds after icons appear
        }
        window.addEventListener('icons:ready', handleIconsReady);
        
        // Scroll listener
        window.addEventListener('scroll', checkScroll, { passive: true });
        
        // Initial check in case page is already scrolled
        checkScroll();
        
        // Fallback: show after 12 seconds if nothing else triggered it
        fallbackTimeout = setTimeout(() => {
          if (!revealed) {
            revealThemeToggle();
          }
        }, 12000);
        
        // Show immediately on reduced motion
        if (reducedMotion) {
          revealThemeToggle();
        }
      }
      
      // Setup initially
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupThemeToggleReveal);
      } else {
        setupThemeToggleReveal();
      }
      
      // Reset and re-setup on pageshow (back navigation from cache)
      window.addEventListener('pageshow', function(event) {
        if (event.persisted) {
          setupThemeToggleReveal();
        }
      });
    })();

    // ===== Bubble freeflow — robust centreing and mobile-safe viewport =====
    (function () {
      const nav = document.getElementById('bubbleNav');
      if (!nav) return;

      const bubbles = Array.from(nav.querySelectorAll('.bubble'));
      if (!bubbles.length) return;

      const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      // --- Helpers ----------------------------------------------------------
      function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
      function clearGapForViewport(){
        if (innerWidth <= 380) return 56;
        if (innerWidth <= 560) return 48;
        return 28;
      }

      function getCenterpieceCenter() {
        const cp = document.getElementById('centerpiece');
        if (cp) {
          const rect = cp.getBoundingClientRect();
          return {
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2,
            w: rect.width,
            h: rect.height,
          };
        }
        // Fallback to viewport center if centerpiece missing
        return { x: innerWidth / 2, y: innerHeight / 2, w: 0, h: 0 };
      }

      // Get bounds of all elements in centerpiece that bubbles should bounce off
      function getCenterpieceElementBounds() {
        const bounds = [];
        const cp = document.getElementById('centerpiece');
        if (!cp) return bounds;
        
        // Add padding around elements for collision detection
        const padding = 60;
        
        // Profile photo
        const photo = document.getElementById('profilePhoto');
        if (photo) {
          const rect = photo.getBoundingClientRect();
          if (rect.width > 0 && rect.height > 0) {
            bounds.push({
              left: rect.left - padding,
              right: rect.right + padding,
              top: rect.top - padding,
              bottom: rect.bottom + padding,
              centerX: rect.left + rect.width / 2,
              centerY: rect.top + rect.height / 2
            });
          }
        }
        
        // Name text
        const name = document.getElementById('name');
        if (name) {
          const rect = name.getBoundingClientRect();
          if (rect.width > 0 && rect.height > 0) {
            bounds.push({
              left: rect.left - padding,
              right: rect.right + padding,
              top: rect.top - padding,
              bottom: rect.bottom + padding,
              centerX: rect.left + rect.width / 2,
              centerY: rect.top + rect.height / 2
            });
          }
        }
        
        // Subtitle
        const subtitle = document.getElementById('subtitle');
        if (subtitle) {
          const rect = subtitle.getBoundingClientRect();
          if (rect.width > 0 && rect.height > 0) {
            bounds.push({
              left: rect.left - padding,
              right: rect.right + padding,
              top: rect.top - padding,
              bottom: rect.bottom + padding,
              centerX: rect.left + rect.width / 2,
              centerY: rect.top + rect.height / 2
            });
          }
        }
        
        // Social links
        const socialLinks = document.querySelectorAll('.social-link');
        socialLinks.forEach(link => {
          const rect = link.getBoundingClientRect();
          if (rect.width > 0 && rect.height > 0) {
            bounds.push({
              left: rect.left - padding,
              right: rect.right + padding,
              top: rect.top - padding,
              bottom: rect.bottom + padding,
              centerX: rect.left + rect.width / 2,
              centerY: rect.top + rect.height / 2
            });
          }
        });
        
        // About section (lede text)
        const aboutInline = document.getElementById('about-inline');
        if (aboutInline) {
          const rect = aboutInline.getBoundingClientRect();
          if (rect.width > 0 && rect.height > 0) {
            bounds.push({
              left: rect.left - padding,
              right: rect.right + padding,
              top: rect.top - padding,
              bottom: rect.bottom + padding,
              centerX: rect.left + rect.width / 2,
              centerY: rect.top + rect.height / 2
            });
          }
        }
        
        // Hobbies section
        const hobbies = document.getElementById('hobbies');
        if (hobbies) {
          const rect = hobbies.getBoundingClientRect();
          if (rect.width > 0 && rect.height > 0) {
            bounds.push({
              left: rect.left - padding,
              right: rect.right + padding,
              top: rect.top - padding,
              bottom: rect.bottom + padding,
              centerX: rect.left + rect.width / 2,
              centerY: rect.top + rect.height / 2
            });
          }
        }
        
        return bounds;
      }

      // Simple gentle collision prevention - no complex physics, just gentle push away
      function calculateCollisionResponse(currentIndex, posX, posY, halfW, halfH) {
        let posCorrectionX = 0;
        let posCorrectionY = 0;
        let hasCollision = false;
        
        // Check collision with centerpiece elements (using current position only)
        const elementBounds = getCenterpieceElementBounds();
        elementBounds.forEach(bounds => {
          const bubbleLeft = posX - halfW;
          const bubbleRight = posX + halfW;
          const bubbleTop = posY - halfH;
          const bubbleBottom = posY + halfH;
          
          // Check if bubble overlaps with element
          const overlapX = Math.min(bubbleRight - bounds.left, bounds.right - bubbleLeft);
          const overlapY = Math.min(bubbleBottom - bounds.top, bounds.bottom - bubbleTop);
          
          if (overlapX > 0 && overlapY > 0) {
            hasCollision = true;
            // Calculate direction away from element center
            const dx = posX - bounds.centerX;
            const dy = posY - bounds.centerY;
            const dist = Math.hypot(dx, dy);
            
            if (dist > 0.0001) {
              const overlapDepth = Math.min(overlapX, overlapY);
              // Very gentle position correction - just enough to prevent overlap
              posCorrectionX += (dx / dist) * overlapDepth * 0.5;
              posCorrectionY += (dy / dist) * overlapDepth * 0.5;
            }
          }
        });
        
        // Check collisions with other bubbles
        for (let i = 0; i < state.length; i++) {
          if (i === currentIndex) continue;
          
          const otherBubble = state[i];
          const otherX = otherBubble.pos.x;
          const otherY = otherBubble.pos.y;
          const otherRect = otherBubble.el.getBoundingClientRect();
          const otherHalfW = otherRect.width / 2;
          const otherHalfH = otherRect.height / 2;
          
          const dx = posX - otherX;
          const dy = posY - otherY;
          const dist = Math.hypot(dx, dy);
          const minDist = Math.max(halfW, halfH) + Math.max(otherHalfW, otherHalfH) + 24;
          
          if (dist < minDist && dist > 0.0001) {
            hasCollision = true;
            const overlapDepth = minDist - dist;
            // Gentle position correction for bubble collisions
            posCorrectionX += (dx / dist) * overlapDepth * 0.4;
            posCorrectionY += (dy / dist) * overlapDepth * 0.4;
          }
        }
        
        return { posCorrectionX, posCorrectionY, hasCollision };
      }

      // Gentle parameters
      const DRIFT_AMP   = 16;    // lively ambient drift
      const DRIFT_FREQ  = 0.18;  // drift cycle
      const BOUNCE_AMP  = 8;     // soft radial bounce
      const BOUNCE_FREQ = 0.08;
      const SPIN        = 0.010; // slightly faster orbit
      const MAG_PULL    = 0.015; // subtle magnetic pull on hover
      const SPRING      = 0.035; // smoother pursuit
      const SPRING_INIT = 0.12;  // faster initial float-in
      const DAMP        = 0.90;  // softer, more organic motion
      const MAX_VEL     = 5;     // allow brisk but smooth entry

      const state = bubbles.map((el, i) => ({
        el,
        angle: (i / bubbles.length) * Math.PI * 2 + (Math.random()-0.5)*0.4,
        radiusMul: 0.9 + Math.random()*0.2,
        pos: { x: 0, y: 0 },
        vel: { x: 0, y: 0 },
        hovering: false,
        hoverT: 0,   // target [0..1]
        hover: 0,    // eased [0..1]
        driftPhase: Math.random() * Math.PI * 2,
        target: { x: 0, y: 0 }
      }));

      // Hover flags (kept even for reduced-motion so we can slightly bias position if desired)
      state.forEach(s => {
        s.el.addEventListener('pointerenter', () => { s.hovering = true; s.hoverT = 1; });
        s.el.addEventListener('pointerleave', () => { s.hovering = false; s.hoverT = 0; });
      });

      // Smoothed pointer (used only when not reduced motion)
      let rawPointer = { x: innerWidth/2, y: innerHeight/2, active: false };
      let filtPointer = { x: rawPointer.x, y: rawPointer.y };
      window.addEventListener('pointermove', (e) => { rawPointer = { x: e.clientX, y: e.clientY, active: true }; }, { passive:true });

      let last = performance.now();
      let initialized = false;
      let rafId = 0;

      function layoutOnce(center, initialPlacement = false){
        // Use a more reasonable base radius calculation
        const baseR = Math.min(
          Math.max(180, 220),
          Math.min(innerWidth, innerHeight) * 0.3
        );
        
        //
        
        state.forEach((s, index) => {
          const rect = s.el.getBoundingClientRect();
          const halfW = rect.width/2;
          const halfH = rect.height/2;
          const pad = 40; // Increased padding for better edge handling

          // Calculate safe boundaries - ensure bubbles stay fully visible
          const minX = halfW + pad;
          const maxX = innerWidth - halfW - pad;
          const minY = halfH + pad;
          const maxY = innerHeight - halfH - pad;

          // Calculate radius with reasonable constraints
          // Ensure clearance from centerpiece bounds by at least bubble radius + gap
          const centerHalfDiag = Math.hypot(center.w/2, center.h/2);
          const minClear = centerHalfDiag + Math.max(halfW, halfH) + clearGapForViewport();
          const maxRadiusX = Math.min(center.x - minX, maxX - center.x);
          const maxRadiusY = Math.min(center.y - minY, maxY - center.y);
          const maxRadius = Math.min(maxRadiusX, maxRadiusY);
          const R = clamp(baseR * s.radiusMul, Math.max(120, minClear), maxRadius);

          let targetX = center.x + Math.cos(s.angle) * R;
          let targetY = center.y + Math.sin(s.angle) * R;

          if (initialPlacement) {
            // Start slightly outside target ring along the radial line, then spring inward
            const offR = R + 220;
            s.pos.x = center.x + Math.cos(s.angle) * offR;
            s.pos.y = center.y + Math.sin(s.angle) * offR;
          } else {
            // Clamp to safe boundaries
            s.pos.x = clamp(targetX, minX, maxX);
            s.pos.y = clamp(targetY, minY, maxY);
          }
          
          //
          
          s.vel.x = 0; s.vel.y = 0;     // reset velocities to avoid bounce on re-layout
          // Clamp and enforce centerpiece clearance on initial placement
          let tx = clamp(targetX, minX, maxX);
          let ty = clamp(targetY, minY, maxY);
          const dx0 = tx - center.x;
          const dy0 = ty - center.y;
          const dist0 = Math.hypot(dx0, dy0);
          const centerHalfDiag2 = Math.hypot(center.w/2, center.h/2);
          const minClear2 = centerHalfDiag2 + Math.max(halfW, halfH) + 24;
          if (dist0 < minClear2 && dist0 > 0.0001){
            const sc = minClear2 / dist0;
            tx = center.x + dx0 * sc;
            ty = center.y + dy0 * sc;
            tx = clamp(tx, minX, maxX);
            ty = clamp(ty, minY, maxY);
          }
          s.target.x = tx;
          s.target.y = ty;
          s.el.style.transform = `translate3d(${s.pos.x - halfW}px, ${s.pos.y - halfH}px, 0)`;
        });
        // leave `initialized` false so first tick uses SPRING_INIT
      }

      function tick(t){
        const dt = Math.min(0.032, (t - last) / 1000);
        last = t;

        // pointer smoothing
        const ALPHA = 0.15;
        filtPointer.x += (rawPointer.x - filtPointer.x) * ALPHA;
        filtPointer.y += (rawPointer.y - filtPointer.y) * ALPHA;

        const center = getCenterpieceCenter();
        // Keep orbit radius independent of typing width to prevent re-spread
        const baseR = Math.min(
          Math.max(180, 220),
          Math.min(innerWidth, innerHeight) * 0.3
        );

        state.forEach((s, idx) => {
          const rect = s.el.getBoundingClientRect();
          const halfW = rect.width/2;
          const halfH = rect.height/2;
          const pad = 40;

          // Calculate safe boundaries
          const minX = halfW + pad;
          const maxX = innerWidth - halfW - pad;
          const minY = halfH + pad;
          const maxY = innerHeight - halfH - pad;

          // ease hover amount for transform and magnet strength
          s.hover += (s.hoverT - s.hover) * 0.18;
          const spinNow = s.hover > 0 ? SPIN * 0.3 : SPIN;
          s.angle += spinNow * dt;

          const time = t * 0.001;
          const drift = Math.sin(time * (DRIFT_FREQ * 2 * Math.PI) + s.driftPhase) * DRIFT_AMP
                       + Math.sin(time * (BOUNCE_FREQ * 2 * Math.PI) + s.driftPhase*0.7) * BOUNCE_AMP;
          
          // Calculate radius - allow bubbles to get closer (collisions will bounce)
          const maxRadiusX = Math.min(center.x - minX, maxX - center.x);
          const maxRadiusY = Math.min(center.y - minY, maxY - center.y);
          const maxRadius = Math.min(maxRadiusX, maxRadiusY);
          const R = clamp(baseR * s.radiusMul + drift, 100, maxRadius); // Lower min radius to allow closer approach

          let tx = center.x + Math.cos(s.angle) * R;
          let ty = center.y + Math.sin(s.angle) * R;

          if (s.hover > 0.001 && rawPointer.active) {
            const pull = MAG_PULL * s.hover; // scale with hover easing
            tx += (filtPointer.x - tx) * pull;
            ty += (filtPointer.y - ty) * pull;
          }

          // Clamp to viewport safe bounds
          tx = clamp(tx, minX, maxX);
          ty = clamp(ty, minY, maxY);

          s.target.x = tx;
          s.target.y = ty;

          const k = initialized ? SPRING : SPRING_INIT;
          s.vel.x = (s.vel.x + (s.target.x - s.pos.x) * k) * DAMP;
          s.vel.y = (s.vel.y + (s.target.y - s.pos.y) * k) * DAMP;

          const speed = Math.hypot(s.vel.x, s.vel.y);
          if (speed > MAX_VEL){
            const scale = MAX_VEL / speed;
            s.vel.x *= scale; s.vel.y *= scale;
          }

          // Update position with velocity
          s.pos.x += s.vel.x;
          s.pos.y += s.vel.y;

          // Apply gentle collision prevention - only position correction, no velocity forces
          // Only apply collision detection after initial load animation (preserve smooth entry)
          if (initialized) {
            const collision = calculateCollisionResponse(
              idx,
              s.pos.x,
              s.pos.y,
              halfW,
              halfH
            );
            
            // Only apply position correction if there's actual collision
            // This prevents overlap gently without causing vibration
            if (collision.hasCollision && (collision.posCorrectionX !== 0 || collision.posCorrectionY !== 0)) {
              // Very gentle, smoothed correction to prevent overlap
              s.pos.x += collision.posCorrectionX * 0.4;
              s.pos.y += collision.posCorrectionY * 0.4;
            }
          }
          
          // Final clamp to ensure we stay in bounds
          s.pos.x = clamp(s.pos.x, minX, maxX);
          s.pos.y = clamp(s.pos.y, minY, maxY);
          const scaleStr = s.hover > 0.001 ? ` scale(${1 + 0.05 * s.hover})` : '';
          s.el.style.transform = `translate3d(${s.pos.x - halfW}px, ${s.pos.y - halfH}px, 0)${scaleStr}`;
        });

        initialized = true;
        rafId = requestAnimationFrame(tick);
      }

      // --- Start logic: orchestrated to begin after icons pop in ---------------
      let started = false;
      function start(initialPlacement = false){
        if (started) return;
        started = true;
        const center = getCenterpieceCenter();
        layoutOnce(center, initialPlacement);
        nav.classList.add('ready');
        if (!reducedMotion){
          last = performance.now();
          rafId = requestAnimationFrame(tick);
        }
      }
      
      // Reset started flag on page load (important for back navigation)
      // This ensures bubbles reinitialize when navigating back
      function resetBubbleState() {
        started = false;
        initialized = false;
        if (rafId) {
          cancelAnimationFrame(rafId);
          rafId = 0;
        }
        nav.classList.remove('ready');
        // Reset bubble positions to initial state
        bubbles.forEach(bubble => {
          bubble.style.transform = '';
          bubble.style.opacity = '';
        });
      }
      
      // Reset on page load
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', resetBubbleState);
      } else {
        resetBubbleState();
      }
      
      // Reset on pageshow event (handles back navigation from cache)
      window.addEventListener('pageshow', function(event) {
        if (event.persisted) {
          resetBubbleState();
        }
      });
      
      // Allow external trigger after icons reveal - remove once:true to allow re-triggering
      function handleBubblesStart() {
        start(true);
      }
      window.addEventListener('bubbles:start', handleBubblesStart);

      // Mobile: first tap acts like hover, second tap navigates
      const elToState = new Map(state.map(s => [s.el, s]));
      const isTouch = 'ontouchstart' in window || (navigator.maxTouchPoints||0) > 0;
      function tryVibrate(ms){ try{ if (navigator && typeof navigator.vibrate === 'function') navigator.vibrate(ms); } catch(_){} }
      if (isTouch){
        bubbles.forEach(el => {
          el.addEventListener('click', (e) => {
            const s = elToState.get(el);
            if (!s) return;
            const armed = el.dataset.armed === '1';
            if (!armed){
              // arm and simulate hover
              el.dataset.armed = '1';
              s.hoverT = 1; s.hover = 1;
              tryVibrate(25);
              // auto-disarm after a short window if no second tap
              setTimeout(() => { if (el.dataset.armed === '1') { el.dataset.armed = ''; s.hoverT = 0; } }, 1400);
              e.preventDefault(); e.stopPropagation();
              return false;
            } else {
              // navigate manually and clear
              el.dataset.armed = '';
              window.location.assign(el.href);
              e.preventDefault(); e.stopPropagation();
              return false;
            }
          }, { passive:false });
        });
      }

      // Removed ResizeObserver on centerpiece/body to avoid re-initialization
      // while typing (which caused a visible re-spread/bounce). Viewport
      // resizes are still handled below.

      // Recenter on viewport changes
      let resizeTimer;
      function handleResize(){
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          cancelAnimationFrame(rafId);
          started = false; 
          initialized = false;
          start(false);
        }, 150);
      }
      window.addEventListener('resize', handleResize);
      window.addEventListener('orientationchange', handleResize);
    })();

    // ===== Panel (removed button) + typing =====
    const menuBtn = document.getElementById('menuBtn');
    const panel = document.getElementById('panel');
    const overlay = document.getElementById('overlay');

    if (menuBtn && panel && overlay){
      function togglePanel(forceOpen){
        const open = forceOpen !== undefined ? forceOpen : !panel.classList.contains('open');
        panel.classList.toggle('open', open);
        overlay.classList.toggle('active', open);
        panel.setAttribute('aria-hidden', (!open).toString());
        const icon = menuBtn.querySelector('i');
        icon.className = open ? 'fa-solid fa-xmark' : 'fa-solid fa-bars';
      }
      menuBtn.addEventListener('click', ()=>togglePanel());
      overlay.addEventListener('click', ()=>togglePanel(false));
      window.addEventListener('keydown', (e)=>{ if (e.key==='Escape' && panel.classList.contains('open')) togglePanel(false); });
    }

    // Typing (~5s total, natural jitter)
    const nameEl = document.getElementById('name');
    const subtitleEl = document.getElementById('subtitle');
    const socialLinksEl = document.querySelector('.social-links');
    const profilePhotoEl = document.getElementById('profilePhoto');
    const profilePhotoContainer = document.querySelector('.profile-photo-container');
    const fullText = nameEl.dataset.text;
    const totalMs = 2200; // faster typing again
    const stepMs = Math.max(30, Math.floor(totalMs / Math.max(1, fullText.length)));
    let idx = 0;
    let typingTimeout = null;
    
    function resetTypingState() {
      // Clear any ongoing typing animation
      if (typingTimeout) {
        clearTimeout(typingTimeout);
        typingTimeout = null;
      }
      idx = 0;
      // Reset visibility states
      if (profilePhotoContainer) profilePhotoContainer.classList.remove('show');
      if (subtitleEl) subtitleEl.classList.remove('show');
      if (socialLinksEl) socialLinksEl.classList.remove('icons-in');
    }
    
    function typeNext(){
      if (idx <= fullText.length){
        nameEl.innerHTML = fullText.slice(0, idx) + '<span class="typing-cursor"></span>';
        idx++; 
        typingTimeout = setTimeout(typeNext, stepMs + Math.random()*40);
      } else {
        nameEl.innerHTML = fullText + '<span class="typing-cursor"></span>';
        setTimeout(()=> {
          // Show profile photo first
          profilePhotoContainer?.classList.add('show');
          setTimeout(()=> {
            subtitleEl.classList.add('show');
            // Pop in icons after a larger gap
            setTimeout(()=>{
              socialLinksEl?.classList.add('icons-in');
              // Notify that icons are ready so About section can begin reveal observation
              window.dispatchEvent(new Event('icons:ready'));
              // After icons pop, start bubbles with initial offscreen placement
              setTimeout(()=>{ window.dispatchEvent(new Event('bubbles:start')); }, 450);
            }, 600);
          }, 300);
        }, 400);
      }
    }
    
    function startTyping() {
      resetTypingState();
      nameEl.textContent = '';
      typingTimeout = setTimeout(typeNext, 300);
    }
    
    // Kick off typing as soon as DOM is ready; also on load as redundancy
    // Always reset and restart on page load (important for back navigation)
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', startTyping);
    } else {
      startTyping();
    }
    
    // Handle pageshow event for back navigation (page loaded from cache)
    window.addEventListener('pageshow', function(event) {
      if (event.persisted) {
        // Page was loaded from cache (back navigation)
        // Reset and restart typing animation
        startTyping();
      }
    });
    
    window.addEventListener('load', () => {
      // Fallback: if typing didn't start, start it now
      if (nameEl && (!nameEl.textContent || nameEl.textContent.trim() === '')) {
        startTyping();
      }
    });

    // Absolute fallbacks so page never feels blank if something blocks animations
    setTimeout(()=>{
      if (!profilePhotoContainer?.classList.contains('show')) profilePhotoContainer?.classList.add('show');
    }, 1200);
    setTimeout(()=>{
      if (!subtitleEl.classList.contains('show')) subtitleEl.classList.add('show');
    }, 1800);
    setTimeout(()=>{
      if (!socialLinksEl.classList.contains('icons-in')) socialLinksEl.classList.add('icons-in');
    }, 2400);
    setTimeout(()=>{
      // ensure bubbles start even if typing flow didn't dispatch
      window.dispatchEvent(new Event('bubbles:start'));
    }, 3200);

    // Tiny parallax on ornaments
    let scrollPos = 0;
    window.addEventListener('scroll', ()=>{
      scrollPos = window.pageYOffset;
      document.querySelectorAll('.floating-element').forEach((el,i)=>{
        const speed = (i+1)*0.5;
        el.style.transform = `translateY(${scrollPos*speed}px)`;
      });
    });


    // Profile photo parallax removed - keeping it fixed in place

    // Page transition on bubble click (for desktop/non-touch)
    (function(){
      const bubbles = document.querySelectorAll('.bubble');
      const pageTransition = document.getElementById('pageTransition');
      const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const isTouch = 'ontouchstart' in window || (navigator.maxTouchPoints||0) > 0;
      
      // Reset is already handled at the top of the script, but ensure it's reset here too
      if (pageTransition) {
        pageTransition.classList.remove('active');
        pageTransition.style.width = '0';
        pageTransition.style.height = '0';
        pageTransition.style.opacity = '0';
        pageTransition.style.pointerEvents = 'none';
      }
      
      if (!bubbles.length || !pageTransition || reducedMotion || isTouch) return;
      
      bubbles.forEach(bubble => {
        // Only add transition for non-touch devices
        bubble.addEventListener('click', function(e){
          const href = this.getAttribute('href');
          if (!href || href === '#' || href.startsWith('mailto:') || href.startsWith('tel:')) return;
          
          // Check if it's an internal link
          try {
            const url = new URL(href, window.location.origin);
            if (url.hostname !== window.location.hostname) return;
          } catch(err) {
            // Relative URL
          }
          
          e.preventDefault();
          
          // Get bubble position at click time
          const rect = this.getBoundingClientRect();
          const x = rect.left + rect.width / 2;
          const y = rect.top + rect.height / 2;
          
          // Position transition overlay at bubble center
          pageTransition.style.left = x + 'px';
          pageTransition.style.top = y + 'px';
          pageTransition.style.transform = 'translate(-50%, -50%)';
          
          // Activate transition
          requestAnimationFrame(() => {
            pageTransition.classList.add('active');
          });
          
          // Navigate after animation - use location.assign to ensure proper history entry
          setTimeout(() => {
            window.location.assign(href);
          }, 400);
        });
      });
    })();

    // ===== IntersectionObserver for section reveal (gated for About+Hobbies) =====
    (function(){
      const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      let observer = null;
      
      function setupObserver() {
        const allSections = Array.from(document.querySelectorAll('.section'));
        const about = document.getElementById('about-inline');
        const hobbies = document.getElementById('hobbies');
        const gated = new Set([about, hobbies]);

        if (reducedMotion) {
          allSections.forEach(s => {
            if (s !== hobbies) s.classList.add('reveal');
          });
          // For hobbies, show immediately on reduced motion
          if (hobbies) hobbies.classList.add('reveal');
          return;
        }

        // Disconnect existing observer if it exists
        if (observer) {
          observer.disconnect();
        }

        const observerOptions = { root: null, rootMargin: '0px', threshold: 0.1 };
        observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              entry.target.classList.add('reveal');
              observer.unobserve(entry.target);
            }
          });
        }, observerOptions);

        // Observe all except the gated ones initially
        allSections.forEach(section => {
          if (!gated.has(section)) observer.observe(section);
        });

        // After icons are in, start observing the gated sections (except hobbies)
        // Remove once:true to allow re-triggering on back navigation
        function handleIconsReady() {
          if (about && observer) observer.observe(about);
        }
        window.addEventListener('icons:ready', handleIconsReady);
      }
      
      // Setup observer initially
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupObserver);
      } else {
        setupObserver();
      }
      
      // Re-setup observer on pageshow (back navigation from cache)
      window.addEventListener('pageshow', function(event) {
        if (event.persisted) {
          setupObserver();
        }
      });
    })();

    // ===== Hobbies section: reveal on scroll or after time (for attentive users) =====
    (function(){
      const hobbies = document.getElementById('hobbies');
      if (!hobbies) return;

      const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      let revealed = false;
      let scrollRevealed = false;
      let timeRevealed = false;
      let timeRevealTimeout = null;
      let fallbackTimeout = null;
      
      function resetHobbiesState() {
        revealed = false;
        scrollRevealed = false;
        timeRevealed = false;
        if (timeRevealTimeout) {
          clearTimeout(timeRevealTimeout);
          timeRevealTimeout = null;
        }
        if (fallbackTimeout) {
          clearTimeout(fallbackTimeout);
          fallbackTimeout = null;
        }
        hobbies.classList.remove('reveal');
      }
      
      function revealHobbies() {
        if (revealed) return;
        revealed = true;
        hobbies.classList.add('reveal');
      }
      
      function setupHobbiesReveal() {
        resetHobbiesState();
        
        // Scroll-based reveal
        function checkScroll() {
          if (scrollRevealed) return;
          const scrollY = window.pageYOffset || document.documentElement.scrollTop;
          if (scrollY > 200) {
            scrollRevealed = true;
            revealHobbies();
          }
        }
        
        // Time-based reveal (after user has been on page for a while)
        function handleIconsReady() {
          timeRevealTimeout = setTimeout(() => {
            if (!timeRevealed && !revealed) {
              timeRevealed = true;
              // Only reveal via time if user hasn't scrolled yet
              if (!scrollRevealed) {
                revealHobbies();
              }
            }
          }, 8000); // 8 seconds after icons appear
        }
        window.addEventListener('icons:ready', handleIconsReady);
        
        // Scroll listener
        window.addEventListener('scroll', checkScroll, { passive: true });
        
        // Initial check in case page is already scrolled
        checkScroll();
        
        // Fallback: show after 12 seconds if nothing else triggered it
        fallbackTimeout = setTimeout(() => {
          if (!revealed) {
            revealHobbies();
          }
        }, 12000);
        
        // Show immediately on reduced motion
        if (reducedMotion) {
          revealHobbies();
        }
      }
      
      // Setup initially
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupHobbiesReveal);
      } else {
        setupHobbiesReveal();
      }
      
      // Reset and re-setup on pageshow (back navigation from cache)
      window.addEventListener('pageshow', function(event) {
        if (event.persisted) {
          setupHobbiesReveal();
        }
      });
    })();

  </script>
</body>
</html>
