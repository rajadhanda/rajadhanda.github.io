<script>
  // ===== Bubble freeflow micro-physics (window-centered, centerpiece-excluding, bias-corrected) =====
  (function () {
    const nav = document.getElementById('bubbleNav');
    if (!nav) return;

    const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (prefersReduced) { nav.classList.remove('freeflow'); return; }

    const bubbles = Array.from(nav.querySelectorAll('.bubble'));
    if (!bubbles.length) return;

    // Robust center (use visualViewport if available to avoid iOS URL-bar weirdness)
    function getViewportCenter() {
      const vv = window.visualViewport;
      const vw = vv ? vv.width  : window.innerWidth;
      const vh = vv ? vv.height : window.innerHeight;
      const ox = vv ? vv.offsetLeft : 0;
      const oy = vv ? vv.offsetTop  : 0;
      return { x: ox + vw / 2, y: oy + vh / 2, vw, vh };
    }

    // Read centerpiece size to push orbit just outside it
    function getCenter() {
      const c = getViewportCenter();
      const cp = document.getElementById('centerpiece');
      if (cp) {
        const r = cp.getBoundingClientRect();
        return { x: c.x, y: c.y, w: r.width, h: r.height, vw: c.vw, vh: c.vh };
      }
      return { x: c.x, y: c.y, w: 0, h: 0, vw: c.vw, vh: c.vh };
    }

    // Tuned for smoothness
    const DRIFT_AMP   = 5;      // px
    const DRIFT_FREQ  = 0.15;   // Hz
    const SPIN        = 0.010;  // rad/sec
    const MAG_PULL    = 0.015;  // hover magnet
    const SPRING      = 0.045;  // steady spring
    const SPRING_INIT = 0.090;  // initial settle
    const DAMP        = 0.975;  // damping
    const MAX_VEL     = 6;      // px/frame

    // Group re-centering to eliminate any systematic drift (e.g., layout quirks)
    const BIAS_K      = 0.08;   // how strongly the swarm recenters per frame (gentle)

    const state = bubbles.map((el, i) => ({
      el,
      angle: (i / bubbles.length) * Math.PI * 2 + (Math.random() - 0.5) * 0.3,
      radiusMul: 0.92 + Math.random() * 0.16,
      pos: { x: 0, y: 0 },
      vel: { x: 0, y: 0 },
      hovering: false,
      driftPhase: Math.random() * Math.PI * 2,
      target: { x: 0, y: 0 }
    }));

    // Smoothed pointer
    let rawPointer = { x: window.innerWidth / 2, y: window.innerHeight / 2, active: false };
    let filtPointer = { x: rawPointer.x, y: rawPointer.y };
    window.addEventListener('pointermove', (e) => {
      rawPointer = { x: e.clientX, y: e.clientY, active: true };
    }, { passive: true });

    state.forEach(s => {
      s.el.addEventListener('pointerenter', () => { s.hovering = true; });
      s.el.addEventListener('pointerleave', () => { s.hovering = false; });
    });

    let last = performance.now();
    let initialized = false;
    let running = true;

    document.addEventListener('visibilitychange', () => {
      running = !document.hidden;
      if (running) { last = performance.now(); requestAnimationFrame(tick); }
    });

    // Re-run on visual viewport changes (mobile URL bar hide/show)
    const vv = window.visualViewport;
    vv && vv.addEventListener('resize', () => requestAnimationFrame(init));
    vv && vv.addEventListener('scroll', () => requestAnimationFrame(init));

    function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

    function tick(t) {
      if (!running) return;
      const dt = Math.min(0.032, (t - last) / 1000);
      last = t;

      // Pointer smoothing
      const ALPHA = 0.12;
      filtPointer.x += (rawPointer.x - filtPointer.x) * ALPHA;
      filtPointer.y += (rawPointer.y - filtPointer.y) * ALPHA;

      const c = getCenter();

      // Base orbit radius: just outside centerpiece + cushion
      const baseR = Math.max(180, Math.max(c.w, c.h) * 0.70 + 60);

      // Compute current swarm center to bias-correct any drift
      let avgX = 0, avgY = 0;
      for (const s of state) { avgX += s.pos.x || c.x; avgY += s.pos.y || c.y; }
      avgX /= state.length; avgY /= state.length;
      const biasX = (c.x - avgX) * BIAS_K;
      const biasY = (c.y - avgY) * BIAS_K;

      state.forEach(s => {
        const spinNow = s.hovering ? SPIN * 0.4 : SPIN;
        s.angle += spinNow * dt;

        const drift = Math.sin(t * 0.001 * (DRIFT_FREQ * 2 * Math.PI) + s.driftPhase) * DRIFT_AMP;

        const halfW = s.el.offsetWidth / 2;
        const halfH = s.el.offsetHeight / 2;
        const pad = 12;

        // Cap radius to keep bubbles fully on-screen
        const capX = (c.vw / 2) - halfW - pad;
        const capY = (c.vh / 2) - halfH - pad;
        const Rcap = Math.max(80, Math.min(capX, capY));

        const R = clamp(baseR * s.radiusMul + drift, 80, Rcap);

        // Position around true center, plus gentle group re-centering bias
        let tx = c.x + Math.cos(s.angle) * R + biasX;
        let ty = c.y + Math.sin(s.angle) * R + biasY;

        // Gentle magnet toward pointer when hovered
        if (s.hovering && rawPointer.active) {
          tx += (filtPointer.x - tx) * MAG_PULL;
          ty += (filtPointer.y - ty) * MAG_PULL;
        }

        const minX = (vv ? vv.offsetLeft : 0) + halfW + pad;
        const maxX = (vv ? vv.offsetLeft + vv.width : window.innerWidth)  - halfW - pad;
        const minY = (vv ? vv.offsetTop  : 0) + halfH + pad;
        const maxY = (vv ? vv.offsetTop  + vv.height: window.innerHeight) - halfH - pad;

        s.target.x = clamp(tx, minX, maxX);
        s.target.y = clamp(ty, minY, maxY);

        const k = initialized ? SPRING : SPRING_INIT;
        s.vel.x += (s.target.x - s.pos.x) * k;
        s.vel.y += (s.target.y - s.pos.y) * k;

        s.vel.x *= DAMP; s.vel.y *= DAMP;
        const speed = Math.hypot(s.vel.x, s.vel.y);
        if (speed > MAX_VEL) {
          const scale = MAX_VEL / speed;
          s.vel.x *= scale; s.vel.y *= scale;
        }

        s.pos.x += s.vel.x;
        s.pos.y += s.vel.y;

        const scale = s.hovering ? ' scale(1.03)' : '';
        s.el.style.transform = `translate3d(${s.pos.x - halfW}px, ${s.pos.y - halfH}px, 0)` + scale;
      });

      initialized = true;
      requestAnimationFrame(tick);
    }

    function init() {
      const c = getCenter();
      const baseR = Math.max(180, Math.max(c.w, c.h) * 0.70 + 60);

      state.forEach(s => {
        const halfW = s.el.offsetWidth / 2;
        const halfH = s.el.offsetHeight / 2;
        const pad = 12;
        const capX = (c.vw / 2) - halfW - pad;
        const capY = (c.vh / 2) - halfH - pad;
        const Rcap = Math.max(80, Math.min(capX, capY));

        const R = clamp(baseR * s.radiusMul, 80, Rcap);
        s.pos.x = c.x + Math.cos(s.angle) * R;
        s.pos.y = c.y + Math.sin(s.angle) * R;

        s.el.style.transform = `translate3d(${s.pos.x - halfW}px, ${s.pos.y - halfH}px, 0)`;
      });

      // Start the loop next frame to ensure correct timebase
      requestAnimationFrame((t)=>{ last = t; tick(t); });
    }

    // Run after all assets (fonts) load to ensure correct measurements
    if (document.readyState === 'complete') init();
    else window.addEventListener('load', init);

    // Re-center on resize
    let rz;
    window.addEventListener('resize', () => {
      cancelAnimationFrame(rz);
      rz = requestAnimationFrame(init);
    });
  })();

  // ===== Panel + typing (unchanged) =====
  const menuBtn = document.getElementById('menuBtn');
  const panel = document.getElementById('panel');
  const overlay = document.getElementById('overlay');
  const aboutLink = document.getElementById('aboutLink');

  function togglePanel(forceOpen){
    const open = forceOpen !== undefined ? forceOpen : !panel.classList.contains('open');
    panel.classList.toggle('open', open);
    overlay.classList.toggle('active', open);
    panel.setAttribute('aria-hidden', (!open).toString());
    const icon = menuBtn.querySelector('i');
    icon.className = open ? 'fa-solid fa-xmark' : 'fa-solid fa-bars';
  }
  menuBtn.addEventListener('click', ()=>togglePanel());
  overlay.addEventListener('click', ()=>togglePanel(false));
  aboutLink?.addEventListener('click', (e)=>{ e.preventDefault(); togglePanel(true); document.getElementById('aboutSection').scrollIntoView({behavior:'smooth',block:'start'}); });
  window.addEventListener('keydown', (e)=>{ if (e.key==='Escape' && panel.classList.contains('open')) togglePanel(false); });

  // Typing (~5s total, natural jitter)
  const nameEl = document.getElementById('name');
  const subtitleEl = document.getElementById('subtitle');
  const fullText = nameEl.dataset.text;
  const totalMs = 5000;
  const stepMs = Math.max(30, Math.floor(totalMs / Math.max(1, fullText.length)));
  let idx = 0;
  function typeNext(){
    if (idx <= fullText.length){
      nameEl.innerHTML = fullText.slice(0, idx) + '<span class="typing-cursor"></span>';
      idx++; setTimeout(typeNext, stepMs + Math.random()*40);
    } else {
      nameEl.innerHTML = fullText + '<span class="typing-cursor"></span>';
      setTimeout(()=> subtitleEl.classList.add('show'), 400);
    }
  }
  window.addEventListener('load', ()=>{ nameEl.textContent=''; setTimeout(typeNext, 500); });

  // Tiny parallax on ornaments
  let scrollPos = 0;
  window.addEventListener('scroll', ()=>{
    scrollPos = window.pageYOffset;
    document.querySelectorAll('.floating-element').forEach((el,i)=>{
      const speed = (i+1)*0.5;
      el.style.transform = `translateY(${scrollPos*speed}px)`;
    });
  });
</script>